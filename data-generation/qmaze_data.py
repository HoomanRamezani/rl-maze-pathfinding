# -*- coding: utf-8 -*-
"""QMaze-Data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VtjsdR3ReewXHq4g8BHXPiZxuWwSR_d7
"""

#Importing neccesary libraries for data creation and visualization
import matplotlib.pyplot as plt
import numpy as np
from random import randint

#Code for simulating a rat in a maze with actions, agent and reward

visited_mark = 0.8  # Cells visited by the rat will be painted by gray 0.8
rat_mark = 0.5      # The current rat cell will be painteg by gray 0.5
LEFT = 0
UP = 1
RIGHT = 2
DOWN = 3

# Actions dictionary
actions_dict = {
    LEFT: 'left',
    UP: 'up',
    RIGHT: 'right',
    DOWN: 'down',
}

num_actions = len(actions_dict)

# Exploration factor
epsilon = 0.1


# maze is a 2d Numpy array of floats between 0.0 to 1.0
# 1.0 corresponds to a free cell, and 0.0 an occupied cell
# rat = (row, col) initial rat position (defaults to (0,0))

class Qmaze(object):
    def __init__(self, maze, rat=(0,0)):
        self._maze = np.array(maze)
        nrows, ncols = self._maze.shape
        self.target = (nrows-1, ncols-1)   # target cell where the "cheese" is
        self.free_cells = [(r,c) for r in range(nrows) for c in range(ncols) if self._maze[r,c] == 1.0]
        self.free_cells.remove(self.target)
        if self._maze[self.target] == 0.0:
            raise Exception("Invalid maze: target cell cannot be blocked!")
        if not rat in self.free_cells:
            raise Exception("Invalid Rat Location: must sit on a free cell")
        self.reset(rat)

    def reset(self, rat):
        self.rat = rat
        self.maze = np.copy(self._maze)
        nrows, ncols = self.maze.shape
        row, col = rat
        self.maze[row, col] = rat_mark
        self.state = (row, col, 'start')
        self.min_reward = -0.5 * self.maze.size
        self.total_reward = 0
        self.visited = set()

    def update_state(self, action):
        nrows, ncols = self.maze.shape
        nrow, ncol, nmode = rat_row, rat_col, mode = self.state

        if self.maze[rat_row, rat_col] > 0.0:
            self.visited.add((rat_row, rat_col))  # mark visited cell

        valid_actions = self.valid_actions()

        if not valid_actions:
            nmode = 'blocked'
        elif action in valid_actions:
            nmode = 'valid'
            if action == LEFT:
                ncol -= 1
            elif action == UP:
                nrow -= 1
            if action == RIGHT:
                ncol += 1
            elif action == DOWN:
                nrow += 1
        else:                  # invalid action, no change in rat position
            mode = 'invalid'

        # new state
        self.state = (nrow, ncol, nmode)

    def get_reward(self):
        rat_row, rat_col, mode = self.state
        nrows, ncols = self.maze.shape
        if rat_row == nrows-1 and rat_col == ncols-1:
            return 1.0
        if mode == 'blocked':
            return self.min_reward - 1
        if (rat_row, rat_col) in self.visited:
            return -0.25
        if mode == 'invalid':
            return -0.75
        if mode == 'valid':
            return -0.04

    def act(self, action):
        self.update_state(action)
        reward = self.get_reward()
        self.total_reward += reward
        status = self.game_status()
        envstate = self.observe()
        return envstate, reward, status

    def observe(self):
        canvas = self.draw_env()
        envstate = canvas.reshape((1, -1))
        return envstate

    def draw_env(self):
        canvas = np.copy(self.maze)
        nrows, ncols = self.maze.shape
        # clear all visual marks
        for r in range(nrows):
            for c in range(ncols):
                if canvas[r,c] > 0.0:
                    canvas[r,c] = 1.0
        # draw the rat
        row, col, valid = self.state
        canvas[row, col] = rat_mark
        return canvas

    def game_status(self):
        if self.total_reward < self.min_reward:
            return 'lose'
        rat_row, rat_col, mode = self.state
        nrows, ncols = self.maze.shape
        if rat_row == nrows-1 and rat_col == ncols-1:
            return 'win'

        return 'not_over'

    def valid_actions(self, cell=None):
        if cell is None:
            row, col, mode = self.state
        else:
            row, col = cell
        actions = [0, 1, 2, 3]
        nrows, ncols = self.maze.shape
        if row == 0:
            actions.remove(1)
        elif row == nrows-1:
            actions.remove(3)

        if col == 0:
            actions.remove(0)
        elif col == ncols-1:
            actions.remove(2)

        if row>0 and self.maze[row-1,col] == 0.0:
            actions.remove(1)
        if row<nrows-1 and self.maze[row+1,col] == 0.0:
            actions.remove(3)

        if col>0 and self.maze[row,col-1] == 0.0:
            actions.remove(0)
        if col<ncols-1 and self.maze[row,col+1] == 0.0:
            actions.remove(2)

        return actions


#show 8x8 maze | WALL = BLACK | RAT = DARK GRAY | PATH = LIGHT GRAY | CHEESE = VERY LIGHT GRAY
def show(qmaze):
    plt.grid('on')
    nrows, ncols = qmaze.maze.shape
    ax = plt.gca()
    ax.set_xticks(np.arange(0.5, nrows, 1))
    ax.set_yticks(np.arange(0.5, ncols, 1))
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    canvas = np.copy(qmaze.maze)
    for row,col in qmaze.visited:
        canvas[row,col] = 0.6
    rat_row, rat_col, _ = qmaze.state
    canvas[rat_row, rat_col] = 0.3   # rat cell
    canvas[nrows-1, ncols-1] = 0.9 # cheese cell
    img = plt.imshow(canvas, interpolation='none', cmap='gray')
    return img

# Applying Depth First Search (DFS) to generate random maze based on entrance and exit (aka cheese) location adapted from https://www.geeksforgeeks.org/random-acyclic-maze-generator-with-given-entry-and-exit-point/

# Class to define structure of a node
class Node:
	def __init__(self, value = None,
			next_element = None):
		self.val = value
		self.next = next_element

# Class to implement a stack
class stack:

	# Constructor
	def __init__(self):
		self.head = None
		self.length = 0

	# Put an item on the top of the stack
	def insert(self, data):
		self.head = Node(data, self.head)
		self.length += 1

	# Return the top position of the stack
	def pop(self):
		if self.length == 0:
			return None
		else:
			returned = self.head.val
			self.head = self.head.next
			self.length -= 1
			return returned

	# Return False if the stack is empty
	# and true otherwise
	def not_empty(self):
		return bool(self.length)

	# Return the top position of the stack
	def top(self):
		return self.head.val

# Function to generate the random maze
def generate_random_maze(r, c, P0, Pf):
	ROWS, COLS = r, c

	# Array with only walls (where paths will
	# be created)
	maze = list(list(0 for _ in range(COLS))
					for _ in range(ROWS))

	# Auxiliary matrices to avoid cycles
	seen = list(list(False for _ in range(COLS))
						for _ in range(ROWS))
	previous = list(list((-1, -1)
	for _ in range(COLS)) for _ in range(ROWS))

	S = stack()

	# Insert initial position
	S.insert(P0)

	# Keep walking on the graph using dfs
	# until we have no more paths to traverse
	# (create)
	while S.not_empty():

		# Remove the position of the Stack
		# and mark it as seen
		x, y = S.pop()
		seen[x][y] = True

		# This is to avoid cycles with adj positions
		if (x + 1 < ROWS) and maze[x + 1][y] == 1 \
		and previous[x][y] != (x + 1, y):
			continue
		if (0 < x) and maze[x-1][y] == 1 \
		and previous[x][y] != (x-1, y):
			continue
		if (y + 1 < COLS) and maze[x][y + 1] == 1 \
		and previous[x][y] != (x, y + 1):
			continue
		if (y > 0) and maze[x][y-1] == 1 \
		and previous[x][y] != (x, y-1):
			continue

		# Mark as walkable position
		maze[x][y] = 1

		# Array to shuffle neighbours before
		# insertion
		to_stack = []

		# Before inserting any position,
		# check if it is in the boundaries of
		# the maze
		# and if it were seen (to avoid cycles)

		# If adj position is valid and was not seen yet
		if (x + 1 < ROWS) and seen[x + 1][y] == False:

			# Mark the adj position as seen
			seen[x + 1][y] = True

			# Memorize the position to insert the
			# position in the stack
			to_stack.append((x + 1, y))

			# Memorize the current position as its
			# previous position on the path
			previous[x + 1][y] = (x, y)

		if (0 < x) and seen[x-1][y] == False:

			# Mark the adj position as seen
			seen[x-1][y] = True

			# Memorize the position to insert the
			# position in the stack
			to_stack.append((x-1, y))

			# Memorize the current position as its
			# previous position on the path
			previous[x-1][y] = (x, y)

		if (y + 1 < COLS) and seen[x][y + 1] == False:

			# Mark the adj position as seen
			seen[x][y + 1] = True

			# Memorize the position to insert the
			# position in the stack
			to_stack.append((x, y + 1))

			# Memorize the current position as its
			# previous position on the path
			previous[x][y + 1] = (x, y)

		if (y > 0) and seen[x][y-1] == False:

			# Mark the adj position as seen
			seen[x][y-1] = True

			# Memorize the position to insert the
			# position in the stack
			to_stack.append((x, y-1))

			# Memorize the current position as its
			# previous position on the path
			previous[x][y-1] = (x, y)

		# Indicates if Pf is a neighbour position
		pf_flag = False
		while len(to_stack):

			# Remove random position
			neighbour = to_stack.pop(randint(0, len(to_stack)-1))

			# Is the final position,
			# remember that by marking the flag
			if neighbour == Pf:
				pf_flag = True

			# Put on the top of the stack
			else:
				S.insert(neighbour)

		# This way, Pf will be on the top
		if pf_flag:
			S.insert(Pf)

	# Mark the initial position
	x0, y0 = P0
	xf, yf = Pf
	maze[x0][y0] = 1
	maze[xf][yf] = 1

	# Return maze formed by the traversed path
	return np.asarray(maze, dtype = 'float')




# Test Run
generate_random_maze(8, 8, (0, 0), (7, 7))

#generating a maze array and initializing a qmaze simulation
maze = generate_random_maze(8, 8, (0, 0), (7, 7))

qmaze = Qmaze(maze)
print(maze)
show(qmaze)

# SEE "THE QMAZE CLASS" and "play_game" cell and beyond from qmaze article "https://www.samyzaf.com/ML/rl/qmaze.html?fbclid=IwAR1GlQIP4X4nrlX81WyJXSBMhIt74-hr413iVZOditFMu0BVBp-5ABCJAW4" for how to implement model on qmaze simulation